<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>不好好做安全的运维足球狗</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="不好好做安全的运维足球狗">
<meta property="og:url" content="https://shana66.github.io/index.html">
<meta property="og:site_name" content="不好好做安全的运维足球狗">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不好好做安全的运维足球狗">
  
    <link rel="alternate" href="/atom.xml" title="不好好做安全的运维足球狗" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">不好好做安全的运维足球狗</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello,football-dog~</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shana66.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-github删除已发布的文件夹" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/28/github删除已发布的文件夹/" class="article-date">
  <time datetime="2018-08-28T10:37:49.000Z" itemprop="datePublished">2018-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生存777/">生存777</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/28/github删除已发布的文件夹/">github删除已发布的文件夹</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在github上只能删除仓库,却无法删除文件夹或文件, 所以只能通过命令来解决</p>
<p>进入master项目文件夹</p>
<p>$ git pull origin master                    # 将远程仓库里面的项目拉下来</p>
<p>$ dir                                       # 查看有哪些文件夹</p>
<p>$ git rm -r –cached shana.github.io        # 删除target文件夹</p>
<p>$ git commit -m ‘删除了文件夹’               # 提交,添加操作说明</p>
<p>$ git push -u origin master                # 将本次更改更新到github项目上去</p>
<p>操作完成.</p>
<p>注:本地项目中的target文件夹不收操作影响,删除的只是远程仓库中的target, 可放心删除</p>
<p>每次增加文件或删除文件，都要commit 然后直接 git push -u origin master，就可以同步到github上了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/28/github删除已发布的文件夹/" data-id="cjlhrnnpa001jwtxu33vrk78q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/github/">github</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/28/hello-world/" class="article-date">
  <time datetime="2018-08-28T10:07:34.630Z" itemprop="datePublished">2018-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/28/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/28/hello-world/" data-id="cjlhrnnpb001lwtxu0e84eudy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GraphQL-在微服务架构中的实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/GraphQL-在微服务架构中的实践/" class="article-date">
  <time datetime="2018-08-27T09:13:00.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/知乎666/">知乎666</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/GraphQL-在微服务架构中的实践/">GraphQL 在微服务架构中的实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在过去的将近半年的时间里，作者一直在使用 GraphQL 这门相对新兴的技术开发 Web 服务，与更早出现的 SOAP 和 REST 相比，GraphQL 其实提供的是一套相对完善的查询语言，而不是类似 REST 的设计规范，所以需要语言的生态提供相应的框架支持，但是由于从它开源至今也只有两三年的时间，所以在使用的过程中，尤其是在微服务架构中实践时确实还会遇到很多问题。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql.png" alt="graphq"></p>
<p>这篇文章中，首先会简单介绍 GraphQL 是什么，它能够解决的问题；在这之后，我们会重点分析 GraphQL 在微服务架构中的使用以及在实践过程中遇到的棘手问题，在最后作者将给出心中合理的 GraphQL 微服务架构的设计，希望能为同样在微服务架构中使用 GraphQL 的工程师提供一定的帮助，至于给出的建议是否能够满足读者在特定业务场景下的需求就需要读者自行判断了。</p>
<p>##graphql</p>
<p>简单对象访问协议（SOAP）从今天来看已经是一门非常古老的 Web 服务技术了，虽然很多服务仍然在使用遵循 SOAP 的接口，但是到今天 REST 风格的面向资源的 API 接口已经非常深入人心，也非常的成熟；但是这篇文章要介绍的主角其实是另一门更加复杂、完备的查询语言 GraphQL。</p>
<p>作为 Facebook 在 2015 年推出的查询语言，GraphQL 能够对 API 中的数据提供一套易于理解的完整描述，使得客户端能够更加准确的获得它需要的数据，目前包括 Facebook、Twitter、GitHub 在内的很多公司都已经在生产环境使用 GraphQL 提供 API；其实无论我们是否决定生产环境中使用 GraphQL，它确实是一门值得学习的技术。</p>
<p>###类型系统</p>
<p>GraphQL 的强大表达能力主要还是来自于它完备的类型系统，与 REST 不同，它将整个 Web 服务中的全部资源看成一个有连接的图，而不是一个个资源孤岛，在访问任何资源时都可以通过资源之间的连接访问其它的资源。</p>
<p><img src="https://img.draveness.me/2018-07-16-graph-query-language.png" alt="graph-query-language"></p>
<p>如上图所示，当我们访问 <code>User</code> 资源时，就可以通过 GraphQL 中的连接访问当前 <code>User</code> 的 <code>Repo</code> 和 <code>Issue</code> 等资源，我们不再需要通过多个 REST 的接口分别获取这些资源，只需要通过如下所示的查询就能一次性拿到全部的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user &#123;</span><br><span class="line">        id</span><br><span class="line">        email</span><br><span class="line">        username</span><br><span class="line">        repos(first: 10) &#123;</span><br><span class="line">            id</span><br><span class="line">            url</span><br><span class="line">            name</span><br><span class="line">            issues(first: 20) &#123;</span><br><span class="line">                id</span><br><span class="line">                author</span><br><span class="line">                title</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GraphQL 这种方式能够将原有 RESTful 风格时的多次请求聚合成一次请求，不仅能够减少多次请求带来的延迟，还能够降低服务器压力，加快前端的渲染速度。它的类型系统也非常丰富，除了标量、枚举、列表和对象等类型之外，还支持接口和联合类型等高级特性。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-schema.png" alt="graphql-schema"></p>
<p>为了能够更好的表示非空和空字段，GraphQL 也引入了 <code>Non-Null</code> 等标识代表非空的类型，例如 <code>String!</code> 表示非空的字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">  query: Query</span><br><span class="line">  mutation: Mutation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Schema 中绝大多数的类型都是普通的对象类型，但是每一个 Schema 中都有两个特殊类型：<code>query</code> 和 <code>mutation</code>，它们是 GraphQL 中所有查询的入口，在使用时所有查询接口都是 <code>query</code> 的子字段，所有改变服务器资源的请求都应该属于 <code>mutation</code> 类型。</p>
<p>###集中式 VS 分散式</p>
<p>GraphQL 以图的形式将整个 Web 服务中的资源展示出来，其实我们可以理解为它将整个 Web 服务以 “SQL” 的方式展示给前端和客户端，服务端的资源最终都被聚合到一张完整的图上，这样客户端可以按照其需求自行调用，类似添加字段的需求其实就不再需要后端多次修改了。</p>
<p><img src="https://img.draveness.me/2018-07-16-yelp-schema.png" alt="yelp-schema"></p>
<p>与 RESTful 不同，每一个的 GraphQL 服务其实对外只提供了一个用于调用内部接口的端点，所有的请求都访问这个暴露出来的唯一端点。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-vs-restful-endpoint.png" alt="graphql-vs-restful-endpoint"></p>
<p>GraphQL 实际上将多个 HTTP 请求聚合成了一个请求，它只是将多个 RESTful 请求的资源变成了一个从根资源 <code>Post</code> 访问其他资源的 <code>Comment</code> 和 <code>Author</code> 的图，多个请求变成了一个请求的不同字段，从原有的分散式请求变成了集中式的请求，这种方式非常适合单体服务直接对外提供 GraphQL 服务，能够在数据源和展示层建立一个非常清晰的分离，同时也能够通过一些强大的工具，例如 <a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener">GraphiQL</a> 直接提供可视化的文档；但是在业务复杂性指数提升的今天，微服务架构成为了解决某些问题时必不可少的解决方案，所以如何在微服务架构中使用 GraphQL 提高前后端之间的沟通效率并降低开发成本成为了一个值得考虑的问题。</p>
<p>###relay-标准</p>
<p>如果说 RESTful 其实是客户端与服务端在 HTTP 协议通信时定义的固定标准，那么 Relay 其实也是我们在使用 GraphQL 可以遵循的一套规范。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-and-relay.png" alt="graphql-and-relay"></p>
<p>这种标准的出现能够让不同的工程师开发出较为相似的通信接口，在一些场景下，例如标识对象和分页这种常见的需求，引入设计良好的标准能够降低开发人员之间的沟通成本。</p>
<p>Relay 标准其实为三个与 API 有关的最常见的问题制定了一些规范：</p>
<ol><br>  <li>提供能够重新获取对象的机制；</li><br>  <li>提供对如何对连接进行分页的描述；</li><br>  <li>标准化 <code>mutation</code> 请求，使它们变得更加可预测；</li><br></ol>

<p>通过将上述的三个问题规范化，能够极大地增加前后端对于接口制定和对接时的工作效率。</p>
<p>####对象标识符</p>
<p><code>Node</code> 是 Relay 标准中定义的一个接口，所有遵循 <code>Node</code> 接口的类型都应该包含一个 <code>id</code> 字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Node &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Faction : Node &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String</span><br><span class="line">  ships: ShipConnection</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Ship : Node &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Faction</code> 和 <code>Ship</code> 两个类型都拥有唯一标识符 <code>id</code> 字段，我们可以通过该标识符重新从服务端取回对应的对象，<code>Node</code> 接口和字段在默认情况下会假定整个服务中的所有资源的 <code>id</code> 都是不同的，但是很多时候我们都会将类型和 <code>id</code> 绑定到一起，组合后才能一个类型特定的 <code>ID</code>；为了保证 <code>id</code> 的不透明性，返回的 <code>id</code> 往往都是 Base64 编码的字符串，GraphQL 服务器接收到对应 <code>id</code> 时进行解码就可以得到相关的信息。</p>
<p>####连接与分页</p>
<p>在一个常见的数据库中，一对多关系是非常常见的，一个 <code>User</code> 可以同时拥有多个 <code>Post</code> 以及多个 <code>Comment</code>，这些资源的数量在理论上不是有穷的，没有办法在同一个请求全部返回，所以要对这部分资源进行分页。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  viewer &#123;</span><br><span class="line">    name</span><br><span class="line">    email</span><br><span class="line">    posts(first: 1) &#123;</span><br><span class="line">      edge &#123;</span><br><span class="line">        cursor</span><br><span class="line">        node &#123;</span><br><span class="line">          title</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Relay 通过抽象出的『连接模型』为一对多的关系提供了分片和分页的支持，在 Relay 看来，当我们获取某一个 <code>User</code> 对应的多个 <code>Post</code> 时，其实是得到了一个 <code>PostConnection</code>，也就是一个连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;viewer&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Draveness&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;i@draveness.me&quot;,</span><br><span class="line">    &quot;posts&quot;: &#123;</span><br><span class="line">      &quot;edges&quot;: [</span><br><span class="line">        &quot;cursor&quot;: &quot;YXJyYXljb25uZWN0aW9uOjI=&quot;,</span><br><span class="line">        &quot;node&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;Post title&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在一个 <code>PostConnection</code> 中会存在多个 <code>PostEdge</code> 对象，其中的 <code>cursor</code> 就是我们用来做分页的字段，所有的 <code>cursor</code> 其实都是 Base64 编码的字符串，这能够提醒调用方 <code>cursor</code> 是一个不透明的指针，拿到当前 <code>cursor</code> 后就可以将它作为 <code>after</code> 参数传到下一个查询中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  viewer &#123;</span><br><span class="line">    name</span><br><span class="line">    email</span><br><span class="line">    posts(first: 1, after: &quot;YXJyYXljb25uZWN0aW9uOjI=&quot;) &#123;</span><br><span class="line">      edge &#123;</span><br><span class="line">        cursor</span><br><span class="line">        node &#123;</span><br><span class="line">          title</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们想要知道当前页是否是最后一页时，其实只需要使用每一个连接中的 <code>PageInfo</code> 对象，其中包含了很多与分页相关的信息，一个连接对象中一般都有以下的结构和字段，例如：<code>Edge</code>、<code>PageInfo</code> 以及游标和节点等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PostConnection</span><br><span class="line">├── PostEdge</span><br><span class="line">│   ├── cursor</span><br><span class="line">│   └── Post</span><br><span class="line">└── PageInfo</span><br><span class="line">    ├── hasNextPage</span><br><span class="line">    ├── hasPreviousPage</span><br><span class="line">    ├── startCursor</span><br><span class="line">    └── endCursor</span><br></pre></td></tr></table></figure></p>
<p>Relay 使用了非常多的功能在连接周围构建抽象，让我们能够更加方便地管理客户端中的游标，整个连接相关的规范其实特别复杂，可以阅读 <a href="https://facebook.github.io/relay/graphql/connections.htm" target="_blank" rel="noopener">Relay Cursor Connections Specification</a> 了解更多与连接和游标有关的设计。</p>
<p>####可变请求</p>
<p>每一个 Web 服务都可以看做一个大型的复杂状态机，这个状态机对外提供两种不同的接口，一种接口是查询接口，它能够查询状态机的当前状态，而另一种接口是可以改变服务器状态的可变操作，例如 <code>POST</code>、<code>DELETE</code> 等请求。</p>
<p><img src="https://img.draveness.me/2018-07-16-webserver-as-a-statemachine.png" alt="webserver-as-a-statemachine"></p>
<p>按照约定，所有的可变请求都应该以动词开头并且它们的输入都以 Input 结尾，与之相对应的，所有的输出都以 Payload 结尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input IntroduceShipInput &#123;</span><br><span class="line">  factionId: ID!</span><br><span class="line">  shipName: String!</span><br><span class="line">  clientMutationId: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IntroduceShipPayload &#123;</span><br><span class="line">  faction: Faction</span><br><span class="line">  ship: Ship</span><br><span class="line">  clientMutationId: String!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，可变请求还可以通过传入 <code>clientMutationId</code> 保证请求的幂等性。</p>
<p>####小结</p>
<p>Facebook 的 Relay 标准其实是一个在 GraphQL 上对于常见领域问题的约定，通过这种约定我们能够减少工程师的沟通成本和项目的维护成本并在多人协作时保证服务对外提供接口的统一。</p>
<p>###n–1-问题</p>
<p>在传统的后端服务中，N + 1 查询的问题就非常明显，由于数据库中一对多的关系非常常见，再加上目前大多服务都使用 ORM 取代了数据层，所以在很多时候相关问题都不会暴露出来，只有真正出现性能问题或者慢查询时才会发现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users LIMIT 3;</span><br><span class="line">SELECT * FROM posts WHERE user_id = 1;</span><br><span class="line">SELECT * FROM posts WHERE user_id = 2;</span><br><span class="line">SELECT * FROM posts WHERE user_id = 3;</span><br><span class="line"></span><br><span class="line">SELECT * FROM users LIMIT 3;</span><br><span class="line">SELECT * FROM posts WHERE user_id IN (1, 2, 3);</span><br></pre></td></tr></table></figure></p>
<p>GraphQL 作为一种更灵活的 API 服务提供方式，相比于传统的 Web 服务更容易出现上述问题，类似的问题在出现时也可能更加严重，所以我们更需要避免 N + 1 问题的发生。</p>
<p>数据库层面的 N + 1 查询我们可以通过减少 SQL 查询的次数来解决，一般我们会将多个 <code>=</code> 查询转换成 <code>IN</code> 查询；但是 GraphQL 中的 N + 1 问题就有些复杂了，尤其是当资源需要通过 RPC 请求从其他微服务中获取时，更不能通过简单的改变 SQL 查询来解决。</p>
<p><img src="https://img.draveness.me/2018-07-16-n-1-problem.png" alt="n-1-proble"></p>
<p>在处理 N + 1 问题之前，我们要真正了解如何解决这一类问题的核心逻辑，也就是将多次查询变成一次查询，将多次操作变成一次操作，这样能够减少由于多次请求增加的额外开销 —— 网络延迟、请求解析等；GraphQL 使用了 DataLoader 从业务层面解决了 N + 1 问题，其核心逻辑就是整个多个请求，通过批量请求的方式解决问题。</p>
<p>##微服务架构</p>
<p>微服务架构在当下已经成为了遇到业务异常复杂、团队人数增加以及高并发等需求或者问题时会使用的常见解决方案，当微服务架构遇到 GraphQL 时就会出现很多理论上的碰撞，会出现非常多的使用方法和解决方案。</p>
<p><img src="https://img.draveness.me/2018-07-16-microservice.png" alt="microservice"></p>
<p>在这一节中，我们将介绍在微服务架构中使用 GraphQL 会遇到哪些常见的问题，对于这些问题有哪些解决方案需要权衡，同时也会分析 GraphQL 的设计理念在融入微服务架构中应该注意什么。</p>
<p>当我们在微服务架构中融入 GraphQL 的标准时，会遇到三个核心问题，这些问题其实主要是从单体服务迁移到微服务架构这种分布式系统时引入的一系列技术难点，这些技术难点以及选择之间的折衷是在微服务中实践 GraphQL 的关键。</p>
<p>###schema 设计</p>
<p>GraphQL 独特的 Schema 设计其实为整个服务的架构带来了非常多的变数，如何设计以及暴露对外的接口决定了我们内部应该如何实现用户的认证与鉴权以及路由层的设计。</p>
<p>从总体来看，微服务架构暴露的 GraphQL 接口应该只有两种；一种接口是分散式的，每一个微服务对外暴露不同的端点，分别对外界提供服务。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-schema-design.png" alt="graphql-schema-design"></p>
<p>在这种情况下，流量的路由是根据用户请求的不同服务进行分发的，也就是我们会有以下的一些 GraphQL API 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://draveness.me/posts/api/graphql</span><br><span class="line">http://draveness.me/comments/api/graphql</span><br><span class="line">http://draveness.me/subscriptions/api/graphql</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到当前博客服务总共由内容、评论以及订阅三个不同的服务来提供，在这时其实并没有充分利用 GraphQL 服务的好处，当客户端或前端同时需要多个服务的资源时，需要分别请求不同服务上的资源，并不能通过一次 HTTP 请求满足全部的需求。</p>
<p>另一种方式其实提供了一种集中式的接口，所有的微服务对外<strong>共同</strong>暴露一个端点，在这时流量的路由就不是根据请求的 URL 了，而是根据请求中不同的字段进行路由。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-endpoints.png" alt="graphql-endpoints"></p>
<p>这种路由的方式并不能够通过传统的 nginx 来做，因为在 nginx 看来整个请求其实只有一个 URL 以及一些参数，我们只有解析请求参数中的查询才能知道客户端到底访问了哪些资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://draveness.me/api/graphql</span><br></pre></td></tr></table></figure></p>
<p>请求的解析其实是对一颗树的解析，这部分解析其实是包含业务逻辑的，在这里我们需要知道的是，这种 Schema 设计下的请求是按照 <code>field</code> 进行路由的，GraphQL 其实帮助我们完成了解析查询树的过程，我们只需要对相应字段实现特定的 Resolver 处理返回的逻辑就可以了。</p>
<p>然而在多个微服务提供 Schema 时，我们需要通过一种机制将多个服务的 Schema 整合起来，这种整合 Schema 的思路最重要的就是需要解决服务之间的重复资源和冲突字段问题，如果多个服务需要同时提供同一个类型的基础资源，例如：<code>User</code> 可以从多种资源间接访问到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  post(id: 1) &#123;</span><br><span class="line">    user &#123;</span><br><span class="line">      id</span><br><span class="line">      email</span><br><span class="line">    &#125;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    content</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>作为微服务的开发者或者提供方来讲，不同的微服务之间的关系是平等的，我们需要一个更高级别或者更面向业务的服务对提供整合 Schema 的功能，确保服务之间的字段与资源类型不会发生冲突。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-services.png" alt="graphql-services"></p>
<p>####前缀</p>
<p>如何解决冲突资源从目前来看有两种不同的方式，一种是为多个服务提供的资源添加命名空间，一般来说就是前缀，在合并 Schema 时，通过添加前缀能够避免不同服务出现重复字段造成冲突的可能。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-schema-prefixing.png" alt="graphql-schema-prefixing"></p>
<p>SourceGraph 在实践 GraphQL 时其实就使用了这种<strong>增加前缀</strong>的方式，这种方式的实现成本比较低，能够快速解决微服务中 Schema 冲突的问题，读者可以阅读 <a href="https://about.sourcegraph.com/graphql/graphql-at-massive-scale-graphql-as-the-glue-in-a-microservice-architecture/" target="_blank" rel="noopener">GraphQL at massive scale: GraphQL as the glue in a microservice architecture</a> 一文了解这种做法的实现细节；这种增加前缀解决冲突的方式优点就是开发成本非常低，但是它将多个服务的资源看做孤岛，没有办法将多个不同服务中的资源关系串联起来，这对于中心化设计的 GraphQL 来说其实会造成一定体验上的丢失。</p>
<p>####粘合</p>
<p>除了增加前缀这种在工程上开发成本非常低的方法之外，GraphQL 官方提供了一种名为 Schema Stitching 的方案，能够将不同服务的 GraphQL Schema 粘合起来并对外暴露统一的接口，这种方式能够将多个服务中的不同资源粘合起来，能够充分利用 GraphQL 的优势。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-schema-stitching.png" alt="graphql-schema-stitching"></p>
<p>为了打通不同服务之间资源的壁垒、建立合理并且完善的 GraphQL API，我们其实需要付出一些额外的工作，也就是在上层完成对公共资源的处理；当对整个 Schema 进行合并时，如果遇到公共资源，就会选用特定的 Resolver 进行解析，这些解析器的逻辑是在 Schema Stitching 时指定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const linkTypeDefs = `</span><br><span class="line">  extend type User &#123;</span><br><span class="line">    chirps: [Chirp]</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure></p>
<p>我们需要在服务层上的业务层对服务之间的公共资源进行定义，并为这些公共资源建立新的 Resolver，当 GraphQL 解析当公共资源时，就会调用我们在合并 Schema 时传入的 Resolver 进行解析和处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const mergedSchema = mergeSchemas(&#123;</span><br><span class="line">  schemas: [</span><br><span class="line">    chirpSchema,</span><br><span class="line">    authorSchema,</span><br><span class="line">    linkTypeDefs,</span><br><span class="line">  ],</span><br><span class="line">  resolvers: &#123;</span><br><span class="line">    User: &#123;</span><br><span class="line">      chirps: &#123;</span><br><span class="line">        fragment: `... on User &#123; id &#125;`,</span><br><span class="line">        resolve(user, args, context, info) &#123;</span><br><span class="line">          return info.mergeInfo.delegateToSchema(&#123;</span><br><span class="line">            schema: chirpSchema,</span><br><span class="line">            operation: &apos;query&apos;,</span><br><span class="line">            fieldName: &apos;chirpsByAuthorId&apos;,</span><br><span class="line">            args: &#123;</span><br><span class="line">              authorId: user.id,</span><br><span class="line">            &#125;,</span><br><span class="line">            context,</span><br><span class="line">            info,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在整个 Schema Stitching 的过程中，最重要的方法其实就是 <code>mergeSchemas</code>，它总共接受三个参数，需要粘合的 Schema 数组、多个 Resolver 以及类型出现冲突时的回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mergeSchemas(&#123;</span><br><span class="line">  schemas: Array&lt;string | GraphQLSchema | Array&lt;GraphQLNamedType&gt;&gt;;</span><br><span class="line">  resolvers?: Array&lt;IResolvers&gt; | IResolvers;</span><br><span class="line">  onTypeConflict?: (</span><br><span class="line">    left: GraphQLNamedType,</span><br><span class="line">    right: GraphQLNamedType,</span><br><span class="line">    info?: &#123;</span><br><span class="line">      left: &#123;</span><br><span class="line">        schema?: GraphQLSchema;</span><br><span class="line">      &#125;;</span><br><span class="line">      right: &#123;</span><br><span class="line">        schema?: GraphQLSchema;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  ) =&gt; GraphQLNamedType;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>Schema Stitching 其实是解决多服务共同对外暴露 Schema 时比较好的方法，这种粘合 Schema 的方法其实是 GraphQL 官方推荐的做法，同时它们也为使用者提供了 JavaScript 的工具，但是它需要我们在合并 Schema 的地方手动对不同 Schema 之间的公共资源以及冲突类型进行处理，还要定义一些用于解析公共类型的 Resolver；除此之外，目前 GraphQL 的 Schema Stitching 功能对于除 JavaScript 之外的语言并没有官方的支持，作为一个承载了<strong>服务发现以及流量路由</strong>等功能的重要组件，稳定是非常重要的，所以应该<strong>慎重考虑</strong>是否应该自研用于 Schema Stitching 组件。</p>
<p>####组合</p>
<p>除了上述的两种方式能够解决对外暴露单一 GraphQL 的问题之外，我们也可以使用非常传统的 RPC 方式组合多个微服务的功能，对外提供统一的 GraphQL 接口：</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-schema-with-rpc.png" alt="graphql-schema-with-rpc"></p>
<p>当我们使用 RPC 的方式解决微服务架构下 GraphQL Schema 的问题时，内部的所有服务组件其实与其他微服务架构中的服务没有太多区别，它们都会对外提供 RPC 接口，只是我们通过另一种方式 GraphQL 整合了多个微服务中的资源。</p>
<p>使用 RPC 解决微服务中的问题其实是一个比较通用同时也是比较稳定的解决方案，GraphQL 作为一种中心化的接口提供方式，通过 RPC 调用其他服务的接口并进行合并和整合其实也是一个比较合理的事情；在这种架构下，我们其实可以在提供 GraphQL 接口的情况下，也让各个微服务直接或者通过其他业务组件对外暴露 RESTful 接口，提供更多的接入方式。</p>
<p>虽然 RPC 的使用能为我们的服务提供更多的灵活性，同时也能够将 GraphQL 相关的功能拆分到单独的服务中，但是这样给我们带来了一些额外的工作量，它需要工程师手动拼接各个服务的接口并对外提供 GraphQL 服务，在遇到业务需求变更时也可能会导致多个服务的修改和更新。</p>
<p>####小结-1</p>
<p>从使用前缀、粘合到使用 RPC 组合各个微服务提供的接口，对外暴露的 Schema 其实是一个由点到面逐渐聚合的过程，同时实现的复杂度也会逐步上升。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-schema-design-technics.png" alt="graphql-schema-design-technics"></p>
<p>在这三种方式中，作者并不推荐使用前缀的方式隔离多个微服务提供的接口，这种做法并没有充分利用 GraphQL 的好处，不如使用 RESTful 将多个服务的接口直接解耦，使用 GraphQL 反而是有一些滥用的感觉。</p>
<p>除了使用前缀的做法之外，无论是粘合还是组合都能够提供一个完整的 GraphQL 接口，它们两者都需要在直接对接用户的 GraphQL 服务中对各个微服务提供的接口进行整合，当我们使用 Schema Stitching 时，其实对后面的服务提出了更多的要求 —— 开发微服务的工程师需要掌握 GraphQL Schema 的设计与开发方法，与此同时，各个微服务之间的类型也可能出现冲突，需要在上层进行解决，不过这也减少了一些最前面的 GraphQL 服务的工作量。</p>
<p>在最后，使用组合方式就意味着整个架构中的 GraphQL 服务需要通过组合 RPC 的方式处理与 GraphQL 相关的全部逻辑，相当于把 GraphQL 相关的全部逻辑都抽离到了最前面。</p>
<p>经过几次架构的重构之后，在微服务架构中，作者更倾向于使用 RPC 组合各个微服务功能的方式提供 GraphQL 接口，虽然这样带来了更多的工作量，但是却能拥有更好的灵活性，也不需要其他微服务的开发者了解 GraphQL 相关的设计规范以及约定，让各个服务的职责更加清晰与可控。</p>
<p>###认证与授权</p>
<p>在一个常见的 Web 服务中，如何处理用户的认证以及鉴权是一个比较关键的问题，因为我们需要了解在使用 GraphQL 的服务中我们是如何进行用户的认证与授权的。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-auths.png" alt="graphql-auths"></p>
<p>如果我们决定 Web 服务作为一个整体对外暴露的是 GraphQL 的接口，那么在很大程度上，Schema 设计的方式决定了认证与授权应该如何组织；作为一篇介绍 GraphQL 在微服务架构中实践的文章，我们也自然会介绍在不同 Schema 设计下，用户的认证与授权方式应该如何去做。</p>
<p>上一节中总共提到了三种不同的 Schema 设计方式，分别是：前缀、粘合和组合，这些设计方式在最后都会给出一个如下所示的架构图：</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-microservices.png" alt="graphql-microservices"></p>
<p>使用 GraphQL 的所有结构最终都会由一个中心化的服务对外接受来自客户端的 GraphQL 请求，哪怕它仅仅是一个代理，当我们有了这张 GraphQL 服务的架构图，如何对用户的认证与授权进行设计就变得非常清晰了。</p>
<p>####认证</p>
<p>首先，用户的认证在多个服务中分别实现是大不合理的，如果需要在多个服务中处理用户认证相关的逻辑，相当于将一个服务的职责同时分给了多个服务，这些服务需要共享用户认证相关的表，<code>users</code>、<code>sessions</code> 等等，所以在整个 Web 服务中，由一个服务来处理用户认证相关的逻辑是比较合适的。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-authentication.png" alt="graphql-authentication"></p>
<p>这个服务既可以是作为网关代理的 GraphQL 服务本身，也可以是一个独立的用户认证服务，在每次用户请求时都会通过 RPC 或者其他方式调用该服务提供的接口对用户进行认证，用户的授权功能与认证就有一些不同了。</p>
<p>####授权</p>
<p>我们可以选择在 GraphQL 服务中增加授权的功能，也可以选择在各个微服务中判断当前用户是否对某一资源有权限进行操作，这其实是集中式跟分布式之间的权衡，两种方式都有各自的好处，前者将鉴权的权利留给了各个微服务，让它们进行自治，根据其业务需要判断请求者是否可以访问后者修改资源，而后者其实把整个鉴权的过程解耦了，内部的微服务无条件的信任来自 GraphQL 服务的请求并提供所有的服务。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-authorization.png" alt="graphql-authorization"></p>
<p>上面的设计其实都是在我们只需要对外提供一个 GraphQL 端点时进行的，当业务需要同时提供 B 端、C 端或者管理后台的接口时，设计可能就完全不同了。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-authorization-variant.png" alt="graphql-authorization-variant"></p>
<p>在这时，如果我们将鉴权的工作分给多个内部的微服务，每个服务都需要对不同的 GraphQL 服务（或者 Web 服务）提供不同的接口，然后分别进行鉴权；但是将鉴权的工作交给 GraphQL 服务就是一种比较好的方式了，内部的微服务不需要关心调用者是否有权限访问该资源，鉴权都由最外层的业务服务来处理，实现了比较好的解耦。</p>
<p>当然，完全的信任其他服务的调用其实是一个比较危险的事情，对于一些重要的业务或者请求调用可以通过外部的风控系统进行二次检查判断当前请求方调用的合法性。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-authorization-with-risk-control.png" alt="graphql-authorization-with-risk-contro"></p>
<blockquote><br>  如何实现一个完备并且有效的风控系统并不是这篇文章想要主要介绍的内容，读者可以寻找相关的资料了解风控系统的原理以及模型。<br></blockquote>

<p>####小结-2</p>
<p>认证与授权的设计本来是系统中一件比较灵活的事情，无论我们是否在微服务架构中使用 GraphQL 作为对外的接口，将这部分逻辑交由直接对外暴露的服务是一种比较好的选择，因为直接对外暴露的服务中掌握了更多与当前请求有关的上下文，能够更容易地对来源用户以及其权限进行认证，而重要或者高危的业务操作可以通过额外增加风控服务管理风险，或者在路由层对 RPC 的调用方通过白名单进行限制，这样能够将不同的功能解耦，减少多个服务之间的重复工作。</p>
<p>###路由设计</p>
<p>作为微服务中非常重要的一部分，如何处理路由层的设计也是一个比较关键的问题；但是与认证与鉴权相似的是，Schema 的设计最终其实就决定了请求的路由如何去做。</p>
<p>GraphQL Schema Stitching 其实已经是一套包含路由系统的 GraphQL 在微服务架构的解决方案了，它能够在网关服务器 Resolve 请求时，通过 HTTP 协议将对应请求的片段交由其他微服务进行处理，整个过程不需要手动介入，只有在类型出现冲突时会执行相应的回调。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-routing.png" alt="graphql-routing"></p>
<p>而组合的方式其实就相当于要手动实现 Schema Stitching 中转发请求的工作了，我们需要在对外暴露的 GraphQL 服务中实现相应字段的解析器调用其他服务提供的 HTTP 或者 RPC 接口取到相应的数据。</p>
<p>在 GraphQL 中的路由设计其实与传统微服务架构中的路由设计差不多，只是 GraphQL 提供了 Stitching 的相关工具用来粘合不同服务中的 Schema 并提供转发服务，我们可以选择使用这种粘合的方式，也可以选择在 Resolver 中通过 HTTP 或者 RPC 的方式来自获取用户请求的资源。</p>
<p>##架构的演进</p>
<p>从今年年初选择使用 GraphQL 作为服务对外暴露的 API 到现在大概有半年的事件，服务的架构也在不断演进和改变，在这个过程中确实经历了非常多的问题，也一次一次地对现有的服务架构进行调整，整个演进的过程其实可以分为三个阶段，从使用 RPC 组合的方式到 Schema Stitching 最后再回到使用 RPC。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-architecture-development.png" alt="graphql-architecture-development"></p>
<p>虽然在整个架构演进的过程中，最开始和最终选择的技术方案虽然都是使用 RPC 进行通信，但是在实现的细节上却有着很多的不同以及差异，这也是我们在业务变得逐渐复杂的过程发现的。</p>
<p>###中心化 schema 与 rpc</p>
<p>当整个项目刚刚开始启动时，其实就已经决定了使用微服务架构进行开发，但是由于当时选择使用的技术栈是 Elixir + Phoenx，所以很多基础设施并不完善，例如 gRPC 以及 Protobuf 就没有官方版本的 Elixir 实现，虽然有一些开源项目作者完成的项目，但是都并不稳定，所以最终决定了在 RabbitMQ 上简单实现了一个基于消息队列的 RPC 框架，并通过<strong>组合</strong>的方式对外提供 GraphQL 的接口。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-microservice-rabbitmq-rpc.png" alt="graphql-microservice-rabbitmq-rpc"></p>
<p>RabbitMQ 在微服务架构中承担了消息总线的功能，所有的 RPC 请求其实都被转换成了消息队列中的消息，服务在调用 RPC 时会向 RabbitMQ 对应的队列投递一条消息并持续监听消息的回调，等待其他服务的响应。</p>
<p>这种做法的好处就是 RabbitMQ 中的队列承担了『服务发现』的职能，通过队列的方式将请求方与服务方解耦，对 RPC 请求进行路由，所以下游的消费者（服务方）可以水平扩展，但是这种方式其实也可以由负载均衡来实现，虽然负载均衡由于并不清楚服务方的负载，所以在转发请求时的效果可能没有服务方作为消费者<strong>主动拉</strong>的效率高。</p>
<p>最关键的问题是，手搓的 RPC 框架作为基础服务如果没有经过充分的测试以及生产环境的考验是不成熟的，而且作为语言无关的一种调用方式，我们可能需要为很多语言同时实现 RPC 框架，这其实就带来了非常高的人力、测试和维护成本，现在来看不是一个非常可取的方法。</p>
<p>如果我们抛开语言不谈，在一个比较成熟的语言中使用 RPC 的方式进行通信，确实能降低很多开发和维护的成本，但是也有另外一个比较大的代价，当业务并不稳定需要经常变更时，内部服务会经常为对外暴露的 RPC 接口添加额外的字段，而这也会要求最前面的 GraphQL 服务做额外的工作：</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-service-upgrade.png" alt="graphql-service-upgrade"></p>
<p>每一次服务的修改都会导致三个相关服务或仓库进行更新，这虽然是在微服务架构中是一件比较正常合理的事情，但是在项目的早期阶段这会导致非常多额外的工作量，这也是我们进行第一次架构迁移的主要原因。</p>
<p>###去中心化管理的 schema</p>
<p>这里的去中心化其实并不是指 GraphQL 对外暴露多个端点，而是指 GraphQL 不同 <code>field</code> 的开发过程去中心化，为了解决中心化的 Schema 加上 RPC 带来的开发效率问题并且实践 GraphQL 官方提供的 Schema Stitching 解决方案，我们决定将 Schema 的管理去中心化，由各个微服务对外直接暴露 GraphQL 请求，同时将多个服务的 Schema 进行合并，以此来解决开发的效率问题。</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-microservice-schema-stitching.png" alt="graphql-microservice-schema-stitching"></p>
<p>使用 Schema Stitching 的方式能够将多个服务中不同的 GraphQL Schema 粘合成一个更大的 Schema，这种架构下最关键的组件就是用于 Schema 粘合的工具，在上面已经说到，除了 Javascript 之外的其他语言并没有官方的工具支持，也没有在生产环境中大规模使用，同时因为我们使用的也是一个比较小众的语言 Elixir，所以更不存在一个可以拆箱即用的工具了。</p>
<p>经过评估之后，我们决定在 GraphQL Elixir 实现 <a href="https://github.com/absinthe-graphql/absinthe" target="_blank" rel="noopener">Absinthe</a> 上进行一层包装，并对客户端的请求进行语法与语义的解析，将字段对应的树包装成子查询发送给下游的服务，最终再由最前面的 GraphQL 服务组合起来：</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-schema-stitching-imp.png" alt="graphql-schema-stitching-imp"></p>
<p>GraphQL 前端服务总共包含两个核心组件，分别是 GraphQL Stitcher 和 Dispatcher，其中前者负责向各个 GraphQL 服务请求 <code>IntrospectionQuery</code> 并将获得的所有 Schema 粘合成一颗巨大的树；当客户端进行请求时，Graphql Dispatcher 会通过语法解析当前的请求，并将其中不同的字段以及子字段转换成树后转发给对应的服务。</p>
<p>在实现 GraphQL Stitcher 的过程中，需要格外注意不同服务之间类型冲突的情况，我们在实现的过程中并没有支持类型冲突以及跨服务资源的问题，而是采用了覆盖的方式，这其实有很大的问题，内部的 GraphQL 服务其实并不知道整个 Schema 中有哪些类型是已经被使用的，所以经常会造成服务之间的类型冲突，我们只有在发现时手动增加前缀来解决冲突。</p>
<blockquote><br>  增加前缀是一个比较容易的解决冲突的办法，但是却并不是特别的优雅，使用这种方式的主要原因是，我们发现了由于权限系统的设计缺陷 —— 在引入 B 端用户时无法优雅的实现鉴权，所以选择使用一种比较简单的办法临时解决类型冲突的问题。<br></blockquote>

<p>在开发各种内部服务时，我们通过 <code>scope</code> 的方式对用户<strong>是否有权限读写资源</strong>做了限制，内部服务在执行操作前会先检查请求的用户是否能够读写该资源，然后开始处理真正的业务逻辑，也就是说<strong>用户鉴权是发生在所有的内部服务中的</strong>。</p>
<p>当我们对外暴露的 GraphQL 服务仅仅是面向 C 端用户的时候，使用 <code>scope</code> 并且让内部服务进行鉴权其实能够满足 C 端对于接口的需求，但是当我们需要同时为 B 端用户提供 GraphQL 或者 RESTful 接口时，这种鉴权方式其实就非常尴尬了。</p>
<p><img src="https://img.draveness.me/2018-07-16-authorization-with-scopes.png" alt="authorization-with-scopes"></p>
<p>在微服务架构中，由于各个服务之间的数据库是隔离的，对于一条数据库记录来说，很多内部服务都只能知道当前记录属于哪个用户或者那些用户，所以对于 <code>scope</code> 来说传递资源、读写请求加上来源用户就能够让处理请求的服务判断当前的来源用户是否有权限访问该条记录。</p>
<p>这种结论基于我们做的一条假设 —— 微服务收到的所有请求其实都要求读写<strong>来源用户拥有的资源</strong>，所以在引入 B 端用户时就遇到了比较大的困难，我们采用的临时解决方案就是在当前用户的 <code>scope</code> 中添加一些额外的信息并在内部服务中添加新的接口满足 B 端查询的需要，但是由于 B 端对于资源的查询要求可能非常多样，当我们需要为不同的查询接口进行不同的权限限制，并且在 B 端用户也不能访问全部用户的资源时，<code>scope</code> 的方式就很难表现这种复杂的鉴权需求。</p>
<p>在这种 Schema 管理去中心化的架构中，我们遇到了两个比较重要的问题：</p>
<ol><br>  <li>用于 Schema Stitching 的组件对于 Elixir 语言并没有官方或者大型开源项目的支持，手搓的组件在承载较大的服务负载时会有很大的压力，同时功能也有非常多不完善的地方；</li><br>  <li>在内部服务对于整个请求没有太多上下文的情况下，一旦遇到复杂的鉴权需求时，将鉴权交给内部服务的的设计方式会导致服务之间的耦合增加 —— 微服务之间需要不断传递请求的上下文用于鉴权，同时也增加了开发的成本；</li><br></ol>

<p>###服务网格与 rpc<br><a id="服务网格与-rpc" class="anchor" href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E4%B8%8E-rpc" aria-hidden="true"><span class="octicon octicon-link"></span></a>服务网格与 RPC</p>
<p>使用去中心化管理的 Schema 虽然在一定程度上减少了开发的工作，但是在这种架构下我们也遇到了两个不能接受的问题，为了解决这些问题，我们准备对当前的技术架构做出以下的修改，让各个服务能够更加灵活的通信：</p>
<p><img src="https://img.draveness.me/2018-07-16-graphql-microservice-service-mesh.png" alt="graphql-microservice-service-mesh"></p>
<p>最新的架构设计中，我们使用 <a href="https://linkerd.io/" target="_blank" rel="noopener">linkerd</a> 来处理服务之间的通信，所有的内部服务不在独立对来源请求进行鉴权，它们只负责对外提供 RPC 接口，在这里使用 gRPC 和 Protobuf 对不同服务的接口进行管理，所有的鉴权都发生在最外层的 Web 服务中，面向 C 端用户的 GraphQL 服务以及面向 B 端用户的 Web 服务，分别会对来源的请求进行鉴权，通过鉴权后再向对应服务发起 RPC 请求，请求的路由和流量的转发都由 linkerd 完成。</p>
<blockquote><br>  linkerd 是服务网格（Service Mesh）技术的一个实现，它是一个开源的网络代理，能够在不改变现有服务的基础上为服务提供服务发现、管理、监控等功能，我们在这篇文章中并不会展开介绍服务网格这门技术，有兴趣的读者可以查找相关的资料。<br></blockquote>

<p>由于面向 B 端用户可能涉及到较多的查询请求，并且这些请求非常复杂，我们可以选择使用从库的方式同步其他服务的数据，在服务内部实现相应的查询功能，当然也可以使用数据中心或者仓库的方式将数据处理后提供给面向 B 端用户的外部服务。</p>
<p><img src="https://img.draveness.me/2018-07-16-linkerd-service-mesh.png" alt="linkerd-service-mesh"></p>
<p>这种服务组织方式其实更像是对第一版架构的修改，通过引入 linkerd 解决服务发现、路由以及治理的问题，将一些微服务通用的基础设施交给相对成熟的开源项目负责，而鉴权逻辑被上移到了几个直接对外暴露的 Web 服务中，内部的服务不再承担鉴权的工作，虽然在这时依然会存在一次服务接口的改动，会导致多处进行修改的问题，但是从现在来看这是为了保持服务的灵活带来的代价。</p>
<p>##总结</p>
<p>从刚开始使用 GraphQL 到现在已经过去了将近半年的时间，在微服务中实践 GraphQL 的过程中，我们发现了微服务与 GraphQL 之间设计思路冲突的地方，也就是<strong>去中心化与中心化</strong>。</p>
<p>作为一门中心化的查询语言，GraphQL 在最佳实践中应该只对外暴露一个端点，这个端点会包含当前 Web 服务应该提供的全部资源，并把它们合理的连接成图，但是微服务架构恰恰是相反的思路，它的初衷就是将大服务拆分成独立部署的服务，所以在最后对架构进行设计时，我们分离了这两部分的逻辑，使用微服务架构对服务进行拆分，通过 GraphQL 对微服务接口进行组合并完成鉴权功能，同时满足了两种不同设计的需求。</p>
<p>在架构演进的过程中，我们遇到了很多设计不合理的地方，也因为没有预见到业务扩展带来需求改动，由此导致架构上无法优雅地实现新的需求；最后选择使用服务网格（Service Mesh）的方式对现有的架构进行重构，也是因为微服务治理相关的事情应该由统一的中间层来做，自己重新实现服务治理相关的逻辑成本也非常高，使用服务网格已经与 GraphQL 没有太多的联系了，GraphQL 服务也只是作为一个对外暴露的端点组合内部服务提供的接口，我们也可以将接口换成 RESTful 或者其他形式，这对于整体的架构设计没有太多的影响；回过头来看，当项目刚刚启动时不应该将 GraphQL 接口摆在一个特别重要的位置上，划分服务之间的边界并进行合理的解耦才是影响比较深远的事情。</p>
<p>到最后，我们会发现在微服务架构中，GraphQL 其实只是整个链路中的一环，或许官方提供的一些工具与微服务中的一些问题有关，但是从整个架构来看对外是否使用 GraphQL 其实不是特别的重要，将服务之间的职责进行解耦并对外提供合理的接口才是最关键的，只要架构上的设计合理，我们可以随时引入一个 GraphQL 服务来组合其他服务的功能，其优点在于：</p>
<ol><br>  <li>将多个网络请求合并成一个，减少前后端之间的网络请求次数，加快前端页面的渲染；</li><br>  <li>提供了体验非常好的调试工具 <a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener">GraphiQL</a>，并可以通过代码生成文档，节约文档的维护成本和沟通成本；</li><br></ol>

<p>不得不说 GraphQL 作为一门新兴的技术有着非常多的优点，很多公司都在尝试使用 GraphQL 对外提供 API，虽然目前来说这门技术不算特别成熟，但是却也有巨大的潜力。</p>
<p>##reference</p>
<ul><br>  <li><a href="https://www.ibm.com/developerworks/cn/webservices/0907_rest_soap/index.html" target="_blank" rel="noopener">Web 服务编程，REST 与 SOAP</a></li><br>  <li><a href="https://facebook.github.io/relay/" target="_blank" rel="noopener">GraphQL Relay</a></li><br>  <li><a href="https://facebook.github.io/relay/docs/en/graphql-server-specification.html" target="_blank" rel="noopener">GraphQL Server Specification</a></li><br>  <li><a href="https://facebook.github.io/relay/graphql/connections.htm" target="_blank" rel="noopener">Relay Cursor Connections Specification</a></li><br>  <li><a href="https://engineering.shopify.com/blogs/engineering/solving-the-n-1-problem-for-graphql-through-batching" target="_blank" rel="noopener">Solving the N+1 Problem for GraphQL through Batching – Shopify Engineering</a></li><br>  <li><a href="https://dev-blog.apollodata.com/graphql-at-facebook-by-dan-schafer-38d65ef075af" target="_blank" rel="noopener">How Facebook organizes their GraphQL code</a></li><br>  <li><a href="https://dev-blog.apollodata.com/how-to-build-graphql-servers-87587591ded5" target="_blank" rel="noopener">How to structure GraphQL server code</a></li><br>  <li><a href="https://blog.codeship.com/graphql-as-an-api-gateway-to-micro-services/" target="_blank" rel="noopener">GraphQL as an API Gateway to Microservices</a></li><br>  <li><a href="https://about.sourcegraph.com/graphql/graphql-at-massive-scale-graphql-as-the-glue-in-a-microservice-architecture/" target="_blank" rel="noopener">GraphQL at massive scale: GraphQL as the glue in a microservice architecture</a></li><br>  <li><a href="https://gramps-graphql.github.io/gramps-express/" target="_blank" rel="noopener">GrAMPS Documentation</a></li><br>  <li><a href="https://outcrawl.com/go-graphql-gateway-microservices/" target="_blank" rel="noopener">Using GraphQL with Microservices in Go</a></li><br>  <li><a href="https://linkerd.io/" target="_blank" rel="noopener">Linkerd</a></li><br></ul>

<p>###关于图片和转载<br><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by/4.0/" target="_blank">知识共享署名 4.0 国际许可协议</a>进行许可。<br>转载时请注明原文链接，图片在使用时请保留图片中的全部内容，可适当缩放并在引用处附上图片所在的文章链接，图片使用 Sketch 进行绘制。</p>
<blockquote><br>        原文链接：<a href="/graphql-microservice">GraphQL 在微服务架构中的实践 · 面向信仰编程</a><br>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">Draveness · GitHub</a><br></blockquote>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/27/GraphQL-在微服务架构中的实践/" data-id="cjlhrnnsr005vwtxul7oj6038" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/graphql/">graphql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-docker下运行kalilinux并配置ssh访问" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/docker下运行kalilinux并配置ssh访问/" class="article-date">
  <time datetime="2018-08-27T09:07:00.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生存777/">生存777</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/docker下运行kalilinux并配置ssh访问/">docker下运行kalilinux并配置ssh访问</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Kali Linux是一款开源的基于Debian的渗透测试专用操作系统，系统中包含一系列用于渗透测试的神器。<br>Docker是目前最火热的开源应用容器，发布于2014年6月。它能让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>####Docker+Kali<br>Kali系统开发者Mati Aharoni认为：将Docker与Kali结合的美妙之处在于，Kali被安置在一个非常棒的、干净的容器中。<br>网络安全爱好者与渗透测试工程师们可以尽情驾驭Kali于Windows, Mac或是Linux了。</p>
<p><strong>下面是具体操作，docker环境就不多说了</strong></p>
<h4 id="拉取kalilinux镜像"><a href="#拉取kalilinux镜像" class="headerlink" title="拉取kalilinux镜像"></a>拉取kalilinux镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shana@Ubuntu1604:~$ docker pull kalilinux/kali-linux-docker</span><br></pre></td></tr></table></figure>
<p><img src="https://www.94cto.cn/usr/uploads/2018/08/1524043426.png" alt="kali1.png"></p>
<h4 id="查看镜像ID"><a href="#查看镜像ID" class="headerlink" title="查看镜像ID"></a>查看镜像ID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shana@Ubuntu1604:~$ docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://www.94cto.cn/usr/uploads/2018/08/3746985912.png" alt="kali2.png"></p>
<p>####创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shana@Ubuntu1604:~$ docker run -t -d -p 2222:22 7b9ab7293e68 ## -p 2222:22 将容器22端口映射到宿主机2222端口</span><br></pre></td></tr></table></figure></p>
<p><img src="https://www.94cto.cn/usr/uploads/2018/08/1795360109.png" alt="k3.png"></p>
<p>####进入容器并进行相关配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shana@Ubuntu1604:~$ docker exec -it b7e6eb0da7b3 /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>#####修改root密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@b7e6eb0da7b3:/# passwd root</span><br></pre></td></tr></table></figure></p>
<p><img src="https://www.94cto.cn/usr/uploads/2018/08/1067564822.png" alt="k4.png"></p>
<p>#####安装openssh-server服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@b7e6eb0da7b3:/# apt-get install openssh-server</span><br></pre></td></tr></table></figure></p>
<p>安装成功<br><img src="https://www.94cto.cn/usr/uploads/2018/08/619478051.png" alt="k6.png"></p>
<p>######如下报错找不到安装包则需更换源<br><img src="https://www.94cto.cn/usr/uploads/2018/08/3035947313.png" alt="k5.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@b7e6eb0da7b3:/# cp /etc/apt/sources.list /etc/apt/sources.list.bak </span><br><span class="line">root@b7e6eb0da7b3:/# vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>替换为以下源并保存</p>
<blockquote>
<p>deb <a href="http://mirrors.ustc.edu.cn/kali" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free contrib<br>deb-src <a href="http://mirrors.ustc.edu.cn/kali" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free contrib<br>deb <a href="http://mirrors.ustc.edu.cn/kali" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali</a> kali-rolling main contrib non-free<br>deb-src <a href="http://mirrors.ustc.edu.cn/kali" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali</a> kali-rolling main contrib non-free<br>deb <a href="http://mirrors.ustc.edu.cn/kali-security" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali-security</a> kali-current/updates main contrib non-free<br>deb-src <a href="http://mirrors.ustc.edu.cn/kali-security" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali-security</a> kali-current/updates main contrib non-free</p>
</blockquote>
<p>更新包列表，重新安装openssh-server即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@b7e6eb0da7b3:/# apt-get update  </span><br><span class="line">···</span><br></pre></td></tr></table></figure></p>
<p>####修改ssh配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@b7e6eb0da7b3:/# vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p>
<p>在”#PermitRootLogin prohibit-password”下面一行添加”<br>PermitRootLogin yes”<br><img src="https://www.94cto.cn/usr/uploads/2018/08/1932857429.png" alt="k7.png"></p>
<p>####重启ssh服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@b7e6eb0da7b3:/# service ssh start</span><br></pre></td></tr></table></figure></p>
<p><img src="https://www.94cto.cn/usr/uploads/2018/08/4189294288.png" alt="k8.png"></p>
<p>####安装net-tools，查看容器IP端口是否正常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@b7e6eb0da7b3:/# apt-get install net-tools</span><br><span class="line">root@b7e6eb0da7b3:/# netstat -ant</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 172.17.0.5:59026        202.141.160.110:80      TIME_WAIT  </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN</span><br></pre></td></tr></table></figure></p>
<p>可以看到容器IP为172.17.0.5，22端口开放，<strong>返回宿主机</strong></p>
<p>####测试ssh连接<br>通过容器IP远程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shana@Ubuntu1604:~$ ssh root@172.17.0.5</span><br></pre></td></tr></table></figure></p>
<p><img src="https://www.94cto.cn/usr/uploads/2018/08/223313591.png" alt="k9.png"><br>通过宿主机IP远程（端口为映射的2222，宿主机IP自查）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@b7e6eb0da7b3:~# ssh -p 2222 root@192.168.56.250</span><br></pre></td></tr></table></figure></p>
<p><img src="https://www.94cto.cn/usr/uploads/2018/08/4076907278.png" alt="k10.png"><br><strong>可以看到均成功登入，部署完成</strong></p>
<p>友情提示：<br>kali官方给出了Docker版本，基本上是个空系统，在容器中安装想要的工具直接apt-get即可。 比如安装 tree直接运行apt-get install sqlmap，安装kali所有的工具则运行 <strong>apt-get install kali-linux-all</strong> 直接一套带走，10G左右。<br>最好在配置完KaliLinux后，将container commit一下，不然每次都需要重启服务。嗯，剩下的时间大家自行摸索吧~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/27/docker下运行kalilinux并配置ssh访问/" data-id="cjlhrnnp6001dwtxuurb296dt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kalilinux/">kalilinux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ssh/">ssh</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ubuntu-更换国内源" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/Ubuntu-更换国内源/" class="article-date">
  <time datetime="2018-08-27T08:49:00.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生存777/">生存777</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/Ubuntu-更换国内源/">Ubuntu 更换国内源</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#####Ubuntu系统自带的源都是国外的网址，下载非常慢，所以将国外源更换为国内源</p>
<h4 id="备份原来的源"><a href="#备份原来的源" class="headerlink" title="备份原来的源"></a>备份原来的源</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">cp</span> /etc/apt/sources.<span class="keyword">list</span> /etc/apt/sources.<span class="keyword">list</span>.bak</span><br></pre></td></tr></table></figure>
<p>####更换源<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure></p>
<p>使用gedit打开文档，将下边的阿里源复制进去，然后点击保存关闭。</p>
<p><strong>阿里源</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty main restricted universe multiverse  </span><br><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-security main restricted universe multiverse  </span><br><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-updates main restricted universe multiverse  </span><br><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-proposed main restricted universe multiverse  </span><br><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-backports main restricted universe multiverse  </span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty main restricted universe multiverse  </span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-security main restricted universe multiverse  </span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-updates main restricted universe multiverse  </span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-proposed main restricted universe multiverse  </span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p><strong>更新源</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure></p>
<p><strong>更新软件</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> upgrade</span><br></pre></td></tr></table></figure></p>
<h4 id="其他常用源"><a href="#其他常用源" class="headerlink" title="其他常用源"></a>其他常用源</h4><p><strong>西电源</strong>（只有校内网网线使用，但是不限制流量，还是十分靠谱的）<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="keyword">deb</span> http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="keyword">deb</span> http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#deb http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#deb http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">#deb-src http://linux.xidian.edu.<span class="keyword">cn</span>/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>
<p><strong>清华源</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ xenial-security main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>
<p><strong>网易源</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily-security main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily-proposed main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily-backports main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily-security main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily-proposed main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.<span class="number">163</span>.<span class="keyword">com</span>/ubuntu/ wily-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>
<p><strong>中科大源</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/27/Ubuntu-更换国内源/" data-id="cjlhrnno4000hwtxu7tq2khjo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/">ubuntu</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Access、Hybrid和Trunk三种模式的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/Access、Hybrid和Trunk三种模式的理解/" class="article-date">
  <time datetime="2018-08-27T08:47:32.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生存777/">生存777</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/Access、Hybrid和Trunk三种模式的理解/">Access、Hybrid和Trunk三种模式的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以太网端口的三种链路类型：Access、Hybrid和Trunk</p>
<p>Access类型的端口只能属于1个VLAN，一般用于连接计算机的端口；<br>Trunk类型的端口可以允许多个VLAN通过，可以接收和发送多个VLAN的报文，一般用于交换机之间连接的端口；<br>Hybrid类型的端口可以允许多个VLAN通过，可以接收和发送多个VLAN的报文，可以用于交换机之间连接，也可以用于连接用户的计算机。</p>
<p>Hybrid端口和Trunk端口在接收数据时，处理方法是一样的，唯一不同之处在于发送数据时：Hybrid端口可以允许多个VLAN的报文发送时不打标签，而Trunk端口只允许缺省VLAN的报文发送时不打标签。</p>
<p>在这里大家要理解端口的缺省VLAN这个概念<br>Access端口只属于1个VLAN，所以它的缺省VLAN就是它所在的VLAN，不用设置；<br>Hybrid端口和Trunk端口属于多个VLAN，所以需要设置缺省VLAN ID。缺省情况下，Hybrid端口和Trunk端口的缺省VLAN为VLAN 1<br>如果设置了端口的缺省VLAN ID，当端口接收到不带VLAN Tag的报文后，则将报文转发到属于缺省VLAN的端口；当端口发送带有VLAN Tag的报文时，如果该报文的VLAN ID与端口缺省的VLAN ID相同，则系统将去掉报文的VLAN Tag，然后再发送该报文。<br>注：对于华为交换机缺省VLAN被称为“PVID Vlan”，(PVID为Port-base Vlan ID)， 对于思科交换机缺省VLAN被称为“Native Vlan”</p>
<p>交换机接口出入数据处理过程：<br>Acess端口收报文:<br>收到一个报文,判断是否有VLAN信息：如果没有则打上端口的PVID，并进行交换转发,如果有则直接丢弃（缺省）<br>Acess端口发报文：<br>将报文的VLAN信息剥离，直接发送出去<br>trunk端口收报文：<br>收到一个报文，判断是否有VLAN信息：如果没有则打上端口的PVID，并进行交换转发，如果有判断该trunk端口是否允许该 VLAN的数据进入：如果可以则转发，否则丢弃<br>trunk端口发报文：<br>比较端口的PVID和将要发送报文的VLAN信息，如果两者相等则剥离VLAN信息，再发送，如果不相等则直接发送<br>hybrid端口收报文：<br>收到一个报文,判断是否有VLAN信息：如果没有则打上端口的PVID，并进行交换转发，如果有则判断该hybrid端口是否允许该VLAN的数据进入：如果可以则转发，否则丢弃(此时端口上的untag配置是不用考虑的，untag配置只对发送报文时起作用)</p>
<p>hybrid端口发报文：<br>1、判断该VLAN在本端口的属性（disp interface 即可看到该端口对哪些VLAN是untag， 哪些VLAN是tag）<br>2、如果是untag则剥离VLAN信息，再发送，如果是tag则直接发送</p>
<p>以下案例可以帮助大家深入理解华为交换机的hybrid端口模式<br>[Switch-Ethernet0/1]int e0/1<br>[Switch-Ethernet0/1]port link-type hybrid<br>[Switch-Ethernet0/1]port hybrid pvid vlan 10<br>[Switch-Ethernet0/1]port hybrid vlan 10 20 untagged<br>[Switch-Ethernet0/1] int e0/2<br>[Switch-Ethernet0/2]port link-type hybrid<br>[Switch-Ethernet0/2]port hybrid pvid vlan 20<br>[Switch-Ethernet0/2]port hybrid vlan 10 20 untagged<br>此时inter e0/1和inter e0/2下的所接的PC是可以互通的，但互通时数据所走的往返vlan是不同的。<br>以下以inter e0/1下的所接的pc1访问inter e0/2下的所接的pc2为例进行说明<br>pc1所发出的数据，由inter0/1所在的pvid vlan10封装vlan10的标记后送入交换机，交换机发现inter e0/2允许vlan 10的数据通过，于是数据被转发到inter e0/2上，由于inter e0/2上vlan 10是untagged的，于是交换机此时去除数据包上vlan10的标记，以普通包的形式发给pc2，此时pc1-&gt;p2走的是vlan10<br>再来分析pc2给pc1回包的过程，pc2所发出的数据，由inter0/2所在的pvid vlan20封装vlan20的标记后送入交换机，交换机发现inter e0/1允许vlan 20的数据通过，于是数据被转发到inter e0/1上，由于inter e0/1上vlan 20是untagged的，于是交换机此时去除数据包上vlan20的标记，以普通包的形式发给pc1，此时pc2-&gt;pc1走的是vlan20</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/27/Access、Hybrid和Trunk三种模式的理解/" data-id="cjlhrnnni0001wtxul00o0r9h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/access/">access</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hybrid/">hybrid</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/trunk/">trunk</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ubuntu终端Terminal常用快捷键" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/Ubuntu终端Terminal常用快捷键/" class="article-date">
  <time datetime="2018-08-27T08:40:00.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生存777/">生存777</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/Ubuntu终端Terminal常用快捷键/">Ubuntu终端Terminal常用快捷键</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tab</td>
<td>自动补全</td>
</tr>
<tr>
<td>Ctrl+a</td>
<td>光标移动到开始位置</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>光标移动到最末尾</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>删除此处至末尾的所有内容</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>删除此处至开始的所有内容</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>删除当前字符</td>
</tr>
<tr>
<td>Ctrl+h</td>
<td>删除当前字符前一个字符</td>
</tr>
<tr>
<td>Ctrl+w</td>
<td>删除此处到左边的单词</td>
</tr>
<tr>
<td>Ctrl+y</td>
<td>粘贴由 Ctrl+u ， Ctrl+d ， Ctrl+w 删除的单词</td>
</tr>
<tr>
<td>Ctrl+l</td>
<td>相当于clear，即清屏</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>查找历史命令</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>向回移动光标</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>向前移动光标</td>
</tr>
<tr>
<td>Ctrl+t</td>
<td>将光标位置的字符和前一个字符进行位置交换</td>
</tr>
<tr>
<td>Ctrl+&amp;</td>
<td>恢复 ctrl+h 或者 ctrl+d 或者 ctrl+w 删除的内容</td>
</tr>
<tr>
<td>Ctrl+S</td>
<td>暂停屏幕输出</td>
</tr>
<tr>
<td>Ctrl+Q</td>
<td>继续屏幕输出</td>
</tr>
<tr>
<td>Ctrl+Left-Arrow</td>
<td>光标移动到上一个单词的词首</td>
</tr>
<tr>
<td>Ctrl+Right-Arrow</td>
<td>光标移动到下一个单词的词尾</td>
</tr>
<tr>
<td>Ctrl+p</td>
<td>向上显示缓存命令</td>
</tr>
<tr>
<td>Ctrl+n</td>
<td>向下显示缓存命令</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>关闭终端</td>
</tr>
<tr>
<td>Ctrl+xx</td>
<td>在EOL和当前光标位置移动</td>
</tr>
<tr>
<td>Ctrl+x@</td>
<td>显示可能hostname补全</td>
</tr>
<tr>
<td>Ctrl+c</td>
<td>终止进程/命令</td>
</tr>
<tr>
<td>Shift +上或下</td>
<td>终端上下滚动</td>
</tr>
<tr>
<td>Shift+PgUp/PgDn</td>
<td>终端上下翻页滚动</td>
</tr>
<tr>
<td>Ctrl+Shift+n</td>
<td>新终端</td>
</tr>
<tr>
<td>alt+F2</td>
<td>输入gnome-terminal打开终端</td>
</tr>
<tr>
<td>Shift+Ctrl+T</td>
<td>打开新的标签页</td>
</tr>
<tr>
<td>Shift+Ctrl+W</td>
<td>关闭标签页</td>
</tr>
<tr>
<td>Shift+Ctrl+C</td>
<td>复制</td>
</tr>
<tr>
<td>Shift+Ctrl+V</td>
<td>粘贴</td>
</tr>
<tr>
<td>Alt+数字</td>
<td>切换至对应的标签页 </td>
</tr>
<tr>
<td>Shift+Ctrl+N</td>
<td>打开新的终端窗口 </td>
</tr>
<tr>
<td>Shift+Ctrl+Q</td>
<td>管壁终端窗口 </td>
</tr>
<tr>
<td>Shift+Ctrl+PgUp/PgDn</td>
<td>左移右移标签页 </td>
</tr>
<tr>
<td>Ctrl+PgUp/PgDn</td>
<td>切换标签页 </td>
</tr>
<tr>
<td>F1</td>
<td>打开帮助指南</td>
</tr>
<tr>
<td>F10</td>
<td>激活菜单栏</td>
</tr>
<tr>
<td>F11</td>
<td>全屏切换</td>
</tr>
<tr>
<td>Alt+F</td>
<td>打开 “文件” 菜单（file）</td>
</tr>
<tr>
<td>Alt+E</td>
<td>打开 “编辑” 菜单（edit）</td>
</tr>
<tr>
<td>Alt+V</td>
<td>打开 “查看” 菜单（view）</td>
</tr>
<tr>
<td>Alt+S</td>
<td>打开 “搜索” 菜单（search）</td>
</tr>
<tr>
<td>Alt+T</td>
<td>打开 “终端” 菜单（terminal）</td>
</tr>
<tr>
<td>Alt+H</td>
<td>打开 “帮助” 菜单（help）</td>
</tr>
</tbody>
</table>
<p>另外一些小技巧包括：在终端窗口命令提示符下，连续按两次 Tab 键、或者连续按三次 Esc 键、或者按 Ctrl+I 组合键，将显示所有的命令及工具名称。Application 键即位置在键盘上右 Ctrl 键左边的那个键，作用相当于单击鼠标右键。</p>
<p><strong>然而，最重要的是这些都是可以自己去定义的，怎么提高效率怎么开心就好了嘛～</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/27/Ubuntu终端Terminal常用快捷键/" data-id="cjlhrnnof000nwtxu74ntkg3t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/terminal/">terminal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/">ubuntu</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-postgresql基本操作(个人总结版)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/postgresql基本操作(个人总结版)/" class="article-date">
  <time datetime="2018-08-27T08:32:04.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生存777/">生存777</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/postgresql基本操作(个人总结版)/">postgresql基本操作(个人总结版)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="postgres-基本操作"><a href="#postgres-基本操作" class="headerlink" title="postgres 基本操作"></a>postgres 基本操作</h3><h5 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ psql (连接数据库，默认用户和数据库都是postgres)</span><br><span class="line">$ psql -U &lt;user&gt; -d &lt;dbname&gt;</span><br></pre></td></tr></table></figure>
<h5 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h5><p>// 列举数据库，相当于show databases<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \l</span><br></pre></td></tr></table></figure></p>
<p>// 切换数据库，相当与use dbname<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \c &lt;dbname&gt;</span><br></pre></td></tr></table></figure></p>
<p>// 列举表，相当与show tables<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \dt</span><br></pre></td></tr></table></figure></p>
<p>// 查看表结构，相当于desc<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \d tblname</span><br></pre></td></tr></table></figure></p>
<p>// 创建数据库<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ create database &lt;dbname&gt;</span><br></pre></td></tr></table></figure></p>
<p>// 删除数据库<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ drop database &lt;dbname&gt;</span><br></pre></td></tr></table></figure></p>
<p>// 创建表<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ create table ([字段名<span class="number">1</span>] [类型<span class="number">1</span>] ;,[字段名<span class="number">2</span>] [类型<span class="number">2</span>],......&lt;,primary key (字段名m,字段名n,...)&gt;;);</span><br></pre></td></tr></table></figure></p>
<p>// 在表中插入数据<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ insert into 表名 ([字段名m],[字段名n],......) values ([列m的值],[列n的值],......);</span><br></pre></td></tr></table></figure></p>
<p>// 备份数据库<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pg_dump -U postgres -f /tmp/postgres.sql postgres (导出postgres数据库保存为postgres.sql)</span><br><span class="line">$ pg_dump -U postgres -f /tmp/postgres.sql -t test01 postgres (导出postgres数据库中表test01的数据)</span><br><span class="line">$ pg_dump -U postgres -F t -f /tmp/postgres.tar postgres (导出postgres数据库以tar形式压缩保存为postgres.tar)</span><br></pre></td></tr></table></figure></p>
<p>// 恢复数据库<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ psql -U postgres -f /tmp/postgres.sql bk01 (恢复postgres.sql数据到bk01数据库)</span><br><span class="line">$ pg_restore -U postgres -d bk01 /tmp/postgres.tar  (恢复postgres.tar数据到bk01数据库)</span><br></pre></td></tr></table></figure></p>
<p>#####用户操作</p>
<p>// 切换用户<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \c - &lt;username&gt;</span><br></pre></td></tr></table></figure></p>
<p>//  创建用户并设置密码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ CREATE USER <span class="string">'username'</span> WITH PASSWORD <span class="string">'password'</span>;</span><br><span class="line">$ CREATE ROLE <span class="string">'username'</span> CREATEDB PASSWORD <span class="string">'password'</span> LOGIN; (创建角色并授予创建数据库及密码登录的属性)</span><br></pre></td></tr></table></figure></p>
<p>// 修改用户密码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ALTER USER <span class="string">'username'</span> WITH PASSWORD <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure></p>
<p>// 数据库授权<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ GRANT ALL PRIVILEGES ON DATABASE <span class="string">'dbname'</span> TO <span class="string">'username'</span>;</span><br></pre></td></tr></table></figure></p>
<p>// 修改用户权限<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ALTER ROLE <span class="string">'username'</span> createdb ; (授予创建数据库权限)</span><br><span class="line">$ ALTER ROLE <span class="string">'username'</span> superuser ;(授予超级管理员权限)</span><br></pre></td></tr></table></figure></p>
<p>// 角色属性<br>属性 | 说明<br>– | –<br>login|只有具有 LOGIN 属性的角色可以用做数据库连接的初始角色名。<br>superuser|数据库超级用户<br>createdb|创建数据库权限<br>createrole|允许其创建或删除其他普通的用户角色(超级用户除外)<br>replication|做流复制的时候用到的一个用户属性，一般单独设定。<br>password|在登录时要求指定密码时才会起作用，比如md5或者password模式，跟客户端的连接认证方式有关<br>inherit|用户组对组员的一个继承标志，成员可以继承用户组的权限特性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/27/postgresql基本操作(个人总结版)/" data-id="cjlhrnnpg001pwtxug85mn9wz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/postgresql/">postgresql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用-Docker-容器应该避免的-10-个事情" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/使用-Docker-容器应该避免的-10-个事情/" class="article-date">
  <time datetime="2018-08-27T08:30:13.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生存777/">生存777</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/使用-Docker-容器应该避免的-10-个事情/">使用 Docker 容器应该避免的 10 个事情</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当你最后投入容器的怀抱，发现它能解决很多问题，而且还具有众多的优点:</p>
<p>第一：它是不可变的 – 操作系统，库版本，配置，文件夹和应用都是一样的。您可以使用通过相同QA测试的镜像，使产品具有相同的表现。<br>第二：它是轻量级的 – 容器的内存占用非常小。不需要几百几千MB，它只要对主进程分配内存再加上几十MB。<br>第三：它很快速 – 启动一个容器与启动一个单进程一样快。不需要几分钟，您可以在几秒钟内启动一个全新的容器。</p>
<p>但是，许多用户依然像对待典型的虚拟机那样对待容器。但是他们都忘记了除了与虚拟机相似的部分，容器还有一个很大的优点：它是一次性的。</p>
<p>容器的 准则 ：“容器是临时的”。</p>
<p>这个特性“本身”促使用户改变他们关于使用和管理容器的习惯；我将会向您解释在容器中不应该做这些事，以确保最大地发挥容器的作用。</p>
<p>1) 不要在容器中存储数据 –  容器可能被停止，销毁，或替换。一个运行在容器中的程序版本1.0，应该很容易被1.1的版本替换且不影响或损失数据。有鉴于此，如果你需要存储数据，请存在卷中，并且注意如果两个容器在同一个卷上写数据会导致崩溃。确保你的应用被设计成在共享数据存储上写入。</p>
<p>2) 不要将你的应用发布两份 –  一些人将容器视为虚拟机。他们中的大多数倾向于认为他们应该在现有的运行容器里发布自己的应用。在开发阶段这样是对的，此时你需要不断地部署与调试；但对于质量保证与生产中的一个连续部署的管道，你的应用本该成为镜像的一部分。记住：容器应该保持不变。</p>
<p>3) 不要创建超大镜像 – 一个超大镜像只会难以分发。确保你仅有运行你应用/进程的必需的文件和库。不要安装不必要的包或在创建中运行更新（yum更新）。</p>
<p>4) 不要使用单层镜像 – 要对分层文件系统有更合理的使用，始终为你的操作系统创建你自己的基础镜像层，另外一层为安全和用户定义，一层为库的安装，一层为配置，最后一层为应用。这将易于重建和管理一个镜像，也易于分发。</p>
<p>5) 不要为运行中的容器创建镜像 – 换言之，不要使用“docker commit”命令来创建镜像。这种创建镜像的方法是不可重现的也不能版本化，应该彻底避免。始终使用Dockerfile或任何其他的可完全重现的S2I（源至镜像）方法。</p>
<p>6) 不要只使用“最新”标签 – 最新标签就像Maven用户的“快照”。标签是被鼓励使用的，尤其是当你有一个分层的文件系统。你总不希望当你2个月之后创建镜像时，惊讶地发现你的应用无法运行，因为最顶的分层被非向后兼容的新版本替换，或者创建缓存中有一个错误的“最新”版本。在生产中部署容器时应避免使用最新。</p>
<p>7) 不要在单一容器中运行超过一个进程 – 容器能完美地运行单个进程（http守护进程，应用服务器，数据库），但是如果你不止有一个进程，管理、获取日志、独立更新都会遇到麻烦。</p>
<p>8) 不要在镜像中存储凭据。使用环境变量 –不要将镜像中的任何用户名/密码写死。使用环境变量来从容器外部获取此信息。有一个不错的例子是postgres镜像。</p>
<p>9) 使用非root用户运行进程 – “docker容器默认以root运行。（…）随着docker的成熟，更多的安全默认选项变得可用。现如今，请求root对于其他人是危险的，可能无法在所有环境中可用。你的镜像应该使用USER指令来指令容器的一个非root用户来运行。”（来自 Docker镜像作者指南）</p>
<p>10) 不要依赖IP地址 – 每个容器都有自己的内部IP地址，如果你启动并停止它地址可能会变化。如果你的应用或微服务需要与其他容器通讯，使用任何命名与（或者）环境变量来从一个容器传递合适信息到另一个。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/27/使用-Docker-容器应该避免的-10-个事情/" data-id="cjlhrnnpk001vwtxu0ny9szof" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ubuntu-16.04卸载PostgresQL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/Ubuntu-16.04卸载PostgresQL/" class="article-date">
  <time datetime="2018-08-27T08:27:00.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生存777/">生存777</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/Ubuntu-16.04卸载PostgresQL/">Ubuntu 16.04卸载PostgresQL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shana@Ubuntu1604:~$ ps -aux |grep postgresql <span class="comment">##查看postgresql进程是否仍在运行</span></span><br><span class="line"></span><br><span class="line">shana@Ubuntu1604:~$ sudo service postgresql stop <span class="comment">##暂停服务</span></span><br><span class="line"></span><br><span class="line">shana@Ubuntu1604:~$ sudo apt-get --purge remove postgresql <span class="comment">##卸载及删除安装包</span></span><br></pre></td></tr></table></figure>
<p>删除对应的配置<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shana@Ubuntu1604:~$ sudo rm -r /etc/postgresql/</span><br><span class="line"></span><br><span class="line">shana@Ubuntu1604:~$ sudo rm -r /etc/postgresql-common/</span><br><span class="line"></span><br><span class="line">shana@Ubuntu1604:~$ sudo rm -r /<span class="keyword">var</span>/lib/postgresql/</span><br><span class="line"></span><br><span class="line">shana@Ubuntu1604:~$ sudo userdel -r postgres</span><br><span class="line"></span><br><span class="line">shana@Ubuntu1604:~$ sudo groupdel postgres</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shana66.github.io/2018/08/27/Ubuntu-16.04卸载PostgresQL/" data-id="cjlhrnnnv0009wtxu7fx89g7p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/postgesql/">postgesql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/">ubuntu</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/心路999/">心路999</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生存777/">生存777</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/知乎666/">知乎666</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Buf/">Buf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KVM/">KVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadowsocks/">Shadowsocks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VPS/">VPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xen/">Xen</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/access/">access</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/breadcrumb/">breadcrumb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cen-to-s/">cen'to's</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/centos/">centos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/compose/">compose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/contos/">contos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/error/">error</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/firewalld/">firewalld</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graphql/">graphql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h3c/">h3c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/holland/">holland</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hosts/">hosts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/huawei/">huawei</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hybrid/">hybrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/images/">images</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ipfs/">ipfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/job/">job</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kalilinux/">kalilinux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list/">list</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lu/">lü</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netstat/">netstat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/password/">password</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/peter/">peter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgesql/">postgesql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prism/">prism</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pull/">pull</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/push/">push</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rsync/">rsync</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/switch/">switch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/talking/">talking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tar/">tar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/terminal/">terminal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/">tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/trunk/">trunk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typecho/">typecho</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vlan/">vlan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/watch/">watch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win10/">win10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yum/">yum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/提权/">提权</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/镜像源/">镜像源</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Buf/" style="font-size: 10px;">Buf</a> <a href="/tags/KVM/" style="font-size: 10px;">KVM</a> <a href="/tags/Shadowsocks/" style="font-size: 10px;">Shadowsocks</a> <a href="/tags/VPS/" style="font-size: 10px;">VPS</a> <a href="/tags/Xen/" style="font-size: 10px;">Xen</a> <a href="/tags/access/" style="font-size: 10px;">access</a> <a href="/tags/book/" style="font-size: 10px;">book</a> <a href="/tags/breadcrumb/" style="font-size: 10px;">breadcrumb</a> <a href="/tags/cen-to-s/" style="font-size: 10px;">cen'to's</a> <a href="/tags/centos/" style="font-size: 15px;">centos</a> <a href="/tags/compose/" style="font-size: 10px;">compose</a> <a href="/tags/contos/" style="font-size: 10px;">contos</a> <a href="/tags/docker/" style="font-size: 20px;">docker</a> <a href="/tags/error/" style="font-size: 10px;">error</a> <a href="/tags/firewalld/" style="font-size: 10px;">firewalld</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/graphql/" style="font-size: 10px;">graphql</a> <a href="/tags/h3c/" style="font-size: 10px;">h3c</a> <a href="/tags/holland/" style="font-size: 10px;">holland</a> <a href="/tags/hosts/" style="font-size: 10px;">hosts</a> <a href="/tags/huawei/" style="font-size: 10px;">huawei</a> <a href="/tags/hybrid/" style="font-size: 10px;">hybrid</a> <a href="/tags/images/" style="font-size: 10px;">images</a> <a href="/tags/ipfs/" style="font-size: 10px;">ipfs</a> <a href="/tags/job/" style="font-size: 10px;">job</a> <a href="/tags/kalilinux/" style="font-size: 10px;">kalilinux</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/list/" style="font-size: 10px;">list</a> <a href="/tags/lu/" style="font-size: 10px;">lü</a> <a href="/tags/netstat/" style="font-size: 10px;">netstat</a> <a href="/tags/password/" style="font-size: 10px;">password</a> <a href="/tags/peter/" style="font-size: 10px;">peter</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/postgesql/" style="font-size: 10px;">postgesql</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/prism/" style="font-size: 10px;">prism</a> <a href="/tags/pull/" style="font-size: 10px;">pull</a> <a href="/tags/push/" style="font-size: 10px;">push</a> <a href="/tags/rsync/" style="font-size: 10px;">rsync</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/switch/" style="font-size: 10px;">switch</a> <a href="/tags/talking/" style="font-size: 10px;">talking</a> <a href="/tags/tar/" style="font-size: 10px;">tar</a> <a href="/tags/terminal/" style="font-size: 10px;">terminal</a> <a href="/tags/tree/" style="font-size: 10px;">tree</a> <a href="/tags/trunk/" style="font-size: 10px;">trunk</a> <a href="/tags/typecho/" style="font-size: 10px;">typecho</a> <a href="/tags/ubuntu/" style="font-size: 15px;">ubuntu</a> <a href="/tags/vlan/" style="font-size: 10px;">vlan</a> <a href="/tags/watch/" style="font-size: 10px;">watch</a> <a href="/tags/win10/" style="font-size: 10px;">win10</a> <a href="/tags/yum/" style="font-size: 10px;">yum</a> <a href="/tags/提权/" style="font-size: 10px;">提权</a> <a href="/tags/镜像源/" style="font-size: 10px;">镜像源</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/28/github删除已发布的文件夹/">github删除已发布的文件夹</a>
          </li>
        
          <li>
            <a href="/2018/08/28/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/08/27/GraphQL-在微服务架构中的实践/">GraphQL 在微服务架构中的实践</a>
          </li>
        
          <li>
            <a href="/2018/08/27/docker下运行kalilinux并配置ssh访问/">docker下运行kalilinux并配置ssh访问</a>
          </li>
        
          <li>
            <a href="/2018/08/27/Ubuntu-更换国内源/">Ubuntu 更换国内源</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Shana<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>